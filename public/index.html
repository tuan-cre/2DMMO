<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>MiniMMO</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      /* Prevent mobile zoom on double-tap */
      touch-action: manipulation;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }
    canvas {
      background: #fff;
      display: block;
      border: none;
      /* Prevent mobile zoom and selection */
      touch-action: manipulation;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }
    
    /* Mobile D-pad styles - 3x5 Grid Layout */
    .dpad {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 350px;
      height: 210px;
      display: none;
      grid-template-columns: repeat(5, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 8px;
      padding: 8px;
    }
    
    .dpad-button {
      background: rgba(0, 0, 0, 0.8);
      border: 4px solid rgba(255, 255, 255, 0.8);
      border-radius: 15px;
      color: white;
      font-size: 28px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      touch-action: manipulation;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
      transition: all 0.1s ease;
      cursor: pointer;
    }
    
    .dpad-button:active {
      background: rgba(0, 0, 0, 0.95);
      transform: scale(0.95);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.7);
    }
    
    /* Grid positioning for each button */
    .dpad-up { 
      grid-column: 2; 
      grid-row: 1; 
    }
    .dpad-left { 
      grid-column: 1; 
      grid-row: 2; 
    }
    .dpad-right { 
      grid-column: 3; 
      grid-row: 2; 
    }
    .dpad-down { 
      grid-column: 2; 
      grid-row: 3; 
    }
    
    /* Attack button integrated into grid */
    .dpad-attack {
      grid-column: 5;
      grid-row: 2;
      background: rgba(255, 215, 0, 0.95);
      border: 4px solid rgba(255, 255, 255, 0.8);
      color: #8B4513;
      border-radius: 50%;
    }
    
    .dpad-attack:active {
      background: rgba(255, 215, 0, 1);
      transform: scale(0.95);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.7);
    }
    
    /* Show D-pad on mobile devices */
    @media (max-width: 768px), (pointer: coarse) {
      .dpad {
        display: grid;
      }
      
      /* Adjust scoreboard for mobile */
      .scoreboard {
        top: 10px;
        right: 10px;
        padding: 10px;
        font-size: 12px;
        min-width: 120px;
        max-height: 200px;
      }
    }
    
    /* Additional adjustments for very small screens */
    @media (max-width: 480px) {
      .dpad {
        bottom: 10px;
        width: 320px;
        height: 190px;
        gap: 6px;
        padding: 6px;
      }
      
      .dpad-button {
        font-size: 24px;
      }
    }
    
    /* Scoreboard styles */
    .scoreboard {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px;
      border-radius: 8px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      font-family: Arial, sans-serif;
      font-size: 14px;
      min-width: 150px;
      z-index: 1000;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .scoreboard h3 {
      margin: 0 0 10px 0;
      text-align: center;
      color: #FFD700;
      font-size: 16px;
    }
    
    .score-item {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
      padding: 2px 0;
    }
    
    .score-item.self {
      color: #00FF00;
      font-weight: bold;
    }
    

  </style>
</head>
<body>
  <canvas id="game"></canvas>    <!-- Mobile D-pad -->
  <div class="dpad">
    <div class="dpad-button dpad-up" data-direction="up">‚Üë</div>
    <div class="dpad-button dpad-down" data-direction="down">‚Üì</div>
    <div class="dpad-button dpad-left" data-direction="left">‚Üê</div>
    <div class="dpad-button dpad-right" data-direction="right">‚Üí</div>
    <div class="dpad-button dpad-attack" id="dpad-attack">‚öîÔ∏è</div>
  </div>
  
  <!-- Scoreboard -->
  <div class="scoreboard" id="scoreboard">
    <h3>üèÜ Kill Score</h3>
    <div id="score-list"></div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let players = {};
    let enemies = {};
    let playerScores = {};
    let gameState = { map: null };
    let selfId = null;
    
    // Camera system for following player
    let camera = {
      x: 0,
      y: 0,
      targetX: 0,
      targetY: 0,
      smoothing: 0.1 // Camera smoothing factor (0.1 = smooth, 1 = instant)
    };
    
    // Debug flag for collision visualization
    let showCollisionDebug = false; // Set to false to hide collision outlines
    
    // Toggle collision debug with 'C' key
    window.addEventListener('keydown', (e) => {
      if (e.key === 'c' || e.key === 'C') {
        showCollisionDebug = !showCollisionDebug;
        console.log('Collision debug visualization:', showCollisionDebug ? 'ON' : 'OFF');
      }
    });
    
    // Client-side prediction and lag compensation
    let lastMoveTime = 0;
    const MOVE_THROTTLE = 50; // Faster movement response
    let pendingMoves = [];
    
    // Animation tracking
    let playerAnimations = {};
    let animationFrame = 0;
    
    // Update animation frame counter
    setInterval(() => {
      animationFrame++;
    }, 500); // Change frame every 500ms (slower animation)
    
    // Update camera position
    function updateCamera() {
      if (selfId && players[selfId]) {
        const player = players[selfId];
        
        // Use logical dimensions instead of scaled canvas dimensions
        const viewWidth = canvas.logicalWidth || canvas.width;
        const viewHeight = canvas.logicalHeight || canvas.height;
        
        // Set target position to center the player on screen
        camera.targetX = player.x - viewWidth / 2;
        camera.targetY = player.y - viewHeight / 2;
        
        // If map is available, clamp camera to map boundaries
        if (gameState.map && gameState.map.tileMap) {
          // Calculate actual map dimensions from tile grid instead of using potentially incorrect map.width/height
          const tileSize = gameState.map.tileSize || 32;
          const mapWidth = gameState.map.tileMap[0] ? gameState.map.tileMap[0].length * tileSize : 0;
          const mapHeight = gameState.map.tileMap.length * tileSize;
          
          // Prevent camera from showing beyond map edges
          camera.targetX = Math.max(0, Math.min(mapWidth - viewWidth, camera.targetX));
          camera.targetY = Math.max(0, Math.min(mapHeight - viewHeight, camera.targetY));
          
          // If map is smaller than screen, center it
          if (mapWidth < viewWidth) {
            camera.targetX = (mapWidth - viewWidth) / 2;
          }
          if (mapHeight < viewHeight) {
            camera.targetY = (mapHeight - viewHeight) / 2;
          }
        }
        
        // Smooth camera movement
        camera.x += (camera.targetX - camera.x) * camera.smoothing;
        camera.y += (camera.targetY - camera.y) * camera.smoothing;
        
        // Round camera position to prevent sub-pixel rendering issues
        camera.x = Math.round(camera.x);
        camera.y = Math.round(camera.y);
      }
    }
    
    // Asset management
    const assets = {
      sprites: {},
      backgrounds: {},
      tiles: {},
      loaded: false
    };
    
    // Load assets
    function loadAssets() {
      const assetsToLoad = [
        { type: 'sprites', name: 'player_self1', src: 'assets/sprites/player_self1.png' },
        { type: 'sprites', name: 'player_self2', src: 'assets/sprites/player_self2.png' },
        { type: 'sprites', name: 'player_other1', src: 'assets/sprites/player_other1.png' },
        { type: 'sprites', name: 'player_other2', src: 'assets/sprites/player_other2.png' },
        { type: 'sprites', name: 'enemy', src: 'assets/sprites/enemy.png' },
        { type: 'sprites', name: 'sword_up', src: 'assets/sprites/sword_up.png' },
        { type: 'sprites', name: 'sword_down', src: 'assets/sprites/sword_down.png' },
        { type: 'sprites', name: 'sword_left', src: 'assets/sprites/sword_left.png' },
        { type: 'sprites', name: 'sword_right', src: 'assets/sprites/sword_right.png' },
        { type: 'backgrounds', name: 'grass', src: 'assets/backgrounds/grass_tile.png' },
        { type: 'tiles', name: 'grass', src: 'assets/tiles/grass.png' },
        { type: 'tiles', name: 'rocks', src: 'assets/tiles/rocks.png' }
      ];
      
      let loadedCount = 0;
      const totalAssets = assetsToLoad.length;
      
      // Create fallback sprites if images don't exist
      function createFallbackSprite(color, size = 32, type = 'character') {
        const fallbackCanvas = document.createElement('canvas');
        fallbackCanvas.width = size;
        fallbackCanvas.height = size;
        const fallbackCtx = fallbackCanvas.getContext('2d');
        
        if (type === 'sword') {
          // Draw a simple sword
          fallbackCtx.fillStyle = '#C0C0C0'; // Silver handle
          fallbackCtx.fillRect(14, 20, 4, 8);
          fallbackCtx.fillStyle = '#FFD700'; // Gold blade
          fallbackCtx.fillRect(15, 4, 2, 16);
        } else {
          // Draw a simple character sprite
          fallbackCtx.fillStyle = color;
          fallbackCtx.fillRect(6, 6, 20, 20);
          fallbackCtx.fillStyle = '#333';
          fallbackCtx.fillRect(8, 8, 4, 4); // Eyes
          fallbackCtx.fillRect(14, 8, 4, 4);
          fallbackCtx.fillRect(10, 16, 6, 2); // Mouth
        }
        
        return fallbackCanvas;
      }
      
      // Create fallback background
      function createFallbackBackground() {
        const bgCanvas = document.createElement('canvas');
        bgCanvas.width = 64;
        bgCanvas.height = 64;
        const bgCtx = bgCanvas.getContext('2d');
        
        // Create a simple grass-like pattern
        bgCtx.fillStyle = '#90EE90';
        bgCtx.fillRect(0, 0, 64, 64);
        bgCtx.fillStyle = '#228B22';
        for (let i = 0; i < 20; i++) {
          bgCtx.fillRect(Math.random() * 64, Math.random() * 64, 2, 2);
        }
        
        return bgCanvas;
      }
      
      function checkAssetsLoaded() {
        loadedCount++;
        if (loadedCount === totalAssets) {
          assets.loaded = true;
          console.log('All assets loaded!');
        }
      }
      
      // Load each asset
      assetsToLoad.forEach(asset => {
        const img = new Image();
        img.onload = () => {
          assets[asset.type][asset.name] = img;
          checkAssetsLoaded();
        };
        img.onerror = () => {
          console.log(`Failed to load ${asset.src}, using fallback`);
          // Use fallback sprites
          if (asset.type === 'sprites') {
            if (asset.name.startsWith('sword_')) {
              assets[asset.type][asset.name] = createFallbackSprite('#FFD700', 32, 'sword');
            } else {
              let color;
              if (asset.name.includes('self')) {
                color = '#00FF00';
              } else if (asset.name === 'enemy') {
                color = '#FF0000';
              } else {
                color = '#00FFFF';
              }
              assets[asset.type][asset.name] = createFallbackSprite(color);
            }
          } else if (asset.type === 'backgrounds') {
            assets[asset.type][asset.name] = createFallbackBackground();
          }
          checkAssetsLoaded();
        };
        img.src = asset.src;
      });
    }
    
    // Initialize assets
    loadAssets();
    
    // Update scoreboard display
    function updateScoreboard() {
      const scoreList = document.getElementById('score-list');
      scoreList.innerHTML = '';
      
      // Create array of players with scores for sorting
      const playerScoreArray = [];
      for (let playerId in players) {
        const player = players[playerId];
        const score = playerScores[playerId] || 0;
        playerScoreArray.push({
          id: playerId,
          name: player.name,
          score: score,
          isSelf: playerId === selfId
        });
      }
      
      // Sort by score (highest first)
      playerScoreArray.sort((a, b) => b.score - a.score);
      
      // Display scores
      playerScoreArray.forEach(player => {
        const scoreItem = document.createElement('div');
        scoreItem.className = 'score-item' + (player.isSelf ? ' self' : '');
        scoreItem.innerHTML = `
          <span>${player.name}</span>
          <span>${player.score}</span>
        `;
        scoreList.appendChild(scoreItem);
      });
    }
    
    // Set canvas size to full screen
    function resizeCanvas() {
      // Get the device pixel ratio, but cap it to prevent extreme scaling
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      
      // Get the actual viewport size
      const rect = canvas.getBoundingClientRect();
      const displayWidth = window.innerWidth;
      const displayHeight = window.innerHeight;
      
      // Set the canvas display size (CSS pixels)
      canvas.style.width = displayWidth + 'px';
      canvas.style.height = displayHeight + 'px';
      
      // Set the actual canvas size in memory (scaled for device pixel ratio)
      canvas.width = displayWidth * dpr;
      canvas.height = displayHeight * dpr;
      
      // Scale the drawing context so everything draws at the correct size
      ctx.scale(dpr, dpr);
      
      // For game logic, always use the CSS pixel dimensions
      canvas.logicalWidth = displayWidth;
      canvas.logicalHeight = displayHeight;
      
      console.log(`Canvas resized: display=${displayWidth}x${displayHeight}, actual=${canvas.width}x${canvas.height}, dpr=${dpr}`);
    }
    
    // Initial resize and listen for window resize
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Connect to server - automatically use ws:// for http and wss:// for https
    const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const ws = new WebSocket(protocol + "//" + location.host);

    ws.onmessage = (e) => {
      const data = JSON.parse(e.data);
      
      // Handle position correction from server (when movement is blocked)
      if (data.type === 'position_correction' && selfId) {
        if (players[selfId]) {
          // Only apply position correction if there's a significant difference
          const dx = Math.abs(players[selfId].x - data.x);
          const dy = Math.abs(players[selfId].y - data.y);
          
          if (dx > 5 || dy > 5) { // Only correct if difference is more than 5 pixels
            players[selfId].x = data.x;
            players[selfId].y = data.y;
            players[selfId].facing = data.facing;
            console.log(`Position corrected to (${data.x}, ${data.y})`);
          }
        }
        return;
      }
      
      // Debug: Log when we receive player data with sword swings
      if (data.players) {
        for (let id in data.players) {
          if (data.players[id].isSwinging && id !== selfId) {
            console.log(`Received sword swing data for player ${id}:`, data.players[id]);
          }
        }
      }
      
      if (data.players) {
        // Update animation state for players who moved
        for (let id in data.players) {
          const newPlayer = data.players[id];
          const oldPlayer = players[id];
          
          if (oldPlayer && (newPlayer.x !== oldPlayer.x || newPlayer.y !== oldPlayer.y)) {
            // Player moved, mark as moving
            if (!playerAnimations[id]) playerAnimations[id] = {};
            playerAnimations[id].isMoving = true;
            playerAnimations[id].lastMoveTime = Date.now();
          }
        }
        
        // Merge server data with client prediction
        for (let id in data.players) {
          if (id === selfId) {
            // For self, use a more stable approach but always trust server for sword swings
            const serverPlayer = data.players[id];
            const clientPlayer = players[id];
            
            if (clientPlayer) {
              // Calculate time since last move to determine if we should trust client or server
              const timeSinceLastMove = Date.now() - lastMoveTime;
              
              if (timeSinceLastMove > 150) { // Reduced from 200ms for faster updates
                // Been a while since we moved, trust server position
                players[id] = { ...serverPlayer };
                // Always sync swing data from server
                if (serverPlayer.isSwinging && serverPlayer.swingStartTime) {
                  players[id].swingEndTime = serverPlayer.swingStartTime + 300;
                }
              } else {
                // Recently moved, keep client position but update other data
                players[id].health = serverPlayer.health;
                players[id].maxHealth = serverPlayer.maxHealth;
                players[id].name = serverPlayer.name;
                
                // Only update facing if it's different and we're not currently moving
                if (timeSinceLastMove > 75) { // Reduced from 100ms
                  players[id].facing = serverPlayer.facing;
                }
                
                // ALWAYS handle swing state from server for proper sync - no client prediction
                players[id].isSwinging = serverPlayer.isSwinging;
                players[id].swingStartTime = serverPlayer.swingStartTime;
                players[id].swingEndTime = serverPlayer.swingEndTime;
                
                // Debug log for self sword swings
                if (serverPlayer.isSwinging) {
                  console.log(`Self sword swing synced from server: facing=${serverPlayer.facing}, startTime=${serverPlayer.swingStartTime}`);
                }
              }
            } else {
              // First time seeing this player
              players[id] = { ...serverPlayer };
              if (serverPlayer.isSwinging && serverPlayer.swingStartTime) {
                players[id].swingEndTime = serverPlayer.swingStartTime + 300;
              }
            }
          } else {
            // For other players, always use server data and ensure swing timing is set
            const serverPlayer = data.players[id];
            players[id] = { ...serverPlayer };
            
            // Debug logging for other players' sword swings
            if (serverPlayer.isSwinging) {
              console.log(`Player ${id} is swinging sword! Facing: ${serverPlayer.facing}, StartTime: ${serverPlayer.swingStartTime}`);
            }
            
            if (serverPlayer.isSwinging && serverPlayer.swingStartTime) {
              players[id].swingEndTime = serverPlayer.swingStartTime + 300;
              console.log(`Set swing end time for player ${id}: ${players[id].swingEndTime}`);
            }
          }
        }
        
        // Remove disconnected players
        for (let id in players) {
          if (!data.players[id]) {
            delete players[id];
          }
        }
      }
      if (data.enemies) {
        enemies = data.enemies;
      }
      if (data.scores) {
        playerScores = data.scores;
        updateScoreboard();
      }
      if (data.map) {
        gameState.map = data.map;
        
        // Calculate and log actual map dimensions from tile grid
        if (data.map.tileMap && data.map.tileMap.length > 0) {
          const tileSize = data.map.tileSize || 32;
          const calculatedWidth = data.map.tileMap[0] ? data.map.tileMap[0].length * tileSize : 0;
          const calculatedHeight = data.map.tileMap.length * tileSize;
          console.log(`Map received: ${data.map.tileMap[0] ? data.map.tileMap[0].length : 0} x ${data.map.tileMap.length} tiles`);
          console.log(`Calculated map dimensions: ${calculatedWidth} x ${calculatedHeight} pixels`);
          console.log('Map data boundaries:', data.map.boundaries);
        }
        
        resizeCanvas(); // Ensure canvas is properly sized for camera movement
      }
      if (data.id && !selfId) {
        selfId = data.id;
      }
    };

    // Client-side collision detection
    function checkClientCollision(x, y, radius = 10) {
      // Check if we have map data
      if (!gameState.map || !gameState.map.tileMap || !gameState.map.tileTypes) {
        return false;
      }
      
      const map = gameState.map;
      const tileSize = map.tileSize || 32;
      
      // Check bounds first (match server-side logic exactly)
      if (x < radius || y < radius || x >= map.width - radius || y >= map.height - radius) {
        return true;
      }
      
      // Calculate tile coordinates for the player's bounding box
      const leftTile = Math.floor((x - radius) / tileSize);
      const rightTile = Math.floor((x + radius) / tileSize);
      const topTile = Math.floor((y - radius) / tileSize);
      const bottomTile = Math.floor((y + radius) / tileSize);
      
      // Check all tiles that the player overlaps with
      for (let tileY = topTile; tileY <= bottomTile; tileY++) {
        for (let tileX = leftTile; tileX <= rightTile; tileX++) {
          // Check if tile coordinates are valid
          if (tileY >= 0 && tileY < map.tilesY && tileX >= 0 && tileX < map.tilesX) {
            const tileType = map.tileMap[tileY][tileX];
            const tileData = map.tileTypes[tileType];
            
            // Check if tile is not walkable (match server-side logic exactly)
            if (tileData && (!tileData.walkable || tileData.collision)) {
              return true; // Collision detected
            }
          }
        }
      }
      
      return false; // No collision
    }
    
    // Collision visualization functions
    function drawPlayerCollisionOutline(x, y, radius = 10) {
      if (!showCollisionDebug) return;
      
      const screenX = x - camera.x;
      const screenY = y - camera.y;
      
      // Draw player collision circle (radius 10)
      ctx.strokeStyle = '#00FF00'; // Green for player collision
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]); // Dashed line
      ctx.beginPath();
      ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]); // Reset line dash
    }
    
    function drawTileCollisionOutlines() {
      if (!showCollisionDebug || !gameState.map || !gameState.map.tileMap || !gameState.map.tileTypes) return;
      
      const tileSize = gameState.map.tileSize || 32;
      const tileMap = gameState.map.tileMap;
      const tileTypes = gameState.map.tileTypes;
      
      // Use logical dimensions for viewport calculations
      const viewWidth = canvas.logicalWidth || canvas.width;
      const viewHeight = canvas.logicalHeight || canvas.height;
      
      // Calculate which tiles are visible on screen
      const padding = 1;
      const startTileX = Math.max(0, Math.floor((camera.x - padding * tileSize) / tileSize));
      const endTileX = Math.min(tileMap[0] ? tileMap[0].length - 1 : 0, Math.ceil((camera.x + viewWidth + padding * tileSize) / tileSize));
      const startTileY = Math.max(0, Math.floor((camera.y - padding * tileSize) / tileSize));
      const endTileY = Math.min(tileMap.length - 1, Math.ceil((camera.y + viewHeight + padding * tileSize) / tileSize));
      
      // Draw collision outlines for non-walkable tiles
      ctx.strokeStyle = '#FF0000'; // Red for collision tiles
      ctx.lineWidth = 2;
      ctx.setLineDash([3, 3]); // Dashed line
      
      for (let y = startTileY; y <= endTileY; y++) {
        for (let x = startTileX; x <= endTileX; x++) {
          if (y >= 0 && y < tileMap.length && x >= 0 && x < tileMap[y].length) {
            const tileType = tileMap[y][x];
            const tileTypeData = tileTypes[tileType];
            
            // Only draw outline for collision tiles (like rocks)
            if (tileTypeData && (!tileTypeData.walkable || tileTypeData.collision)) {
              const drawX = x * tileSize - camera.x;
              const drawY = y * tileSize - camera.y;
              
              // Draw collision box outline
              ctx.strokeRect(drawX, drawY, tileSize, tileSize);
            }
          }
        }
      }
      
      ctx.setLineDash([]); // Reset line dash
    }

    // ...existing code...
    // Movement function with client-side prediction
    function movePlayer(direction = null) {
      const now = Date.now();
      
      // Throttle movement commands to reduce server load
      if (now - lastMoveTime < MOVE_THROTTLE) {
        return;
      }
      lastMoveTime = now;
      
      const moveMap = {
        up: [0, -12],    
        down: [0, 12],
        left: [-12, 0],
        right: [12, 0]
      };
      
      if (moveMap[direction]) {
        const dx = moveMap[direction][0];
        const dy = moveMap[direction][1];
        
        // Client-side prediction: update our own position immediately
        if (selfId && players[selfId]) {
          const currentPlayer = players[selfId];
          
          // Use map boundaries if available, otherwise use canvas boundaries
          // Match server-side boundary logic exactly (player radius = 10)
          let minX = 10;
          let minY = 10;
          let maxX = canvas.width - 10;
          let maxY = canvas.height - 10;
          
          if (gameState.map && gameState.map.tileMap) {
            // Calculate actual map dimensions from tile grid
            const tileSize = gameState.map.tileSize || 32;
            const mapWidth = gameState.map.tileMap[0] ? gameState.map.tileMap[0].length * tileSize : canvas.width;
            const mapHeight = gameState.map.tileMap.length * tileSize;
            
            minX = 10;
            minY = 10;
            maxX = mapWidth - 10;
            maxY = mapHeight - 10;
          }
          
          const newX = Math.max(minX, Math.min(maxX, currentPlayer.x + dx));
          const newY = Math.max(minY, Math.min(maxY, currentPlayer.y + dy));
          
          // Check for collisions before updating position
          if (!checkClientCollision(newX, newY, 10)) {
            // Only update if the position actually changed
            if (newX !== currentPlayer.x || newY !== currentPlayer.y) {
              players[selfId].x = newX;
              players[selfId].y = newY;
              
              // Update facing direction immediately
              if (dx > 0) players[selfId].facing = 'right';
              else if (dx < 0) players[selfId].facing = 'left';
              else if (dy > 0) players[selfId].facing = 'down';
              else if (dy < 0) players[selfId].facing = 'up';
              
              // Send to server
              ws.send(JSON.stringify({ 
                type: "move", 
                dx: dx, 
                dy: dy
              }));
            }
          } else {
            // Client detected collision - don't move and don't send to server
            console.log(`Client collision detected at (${newX}, ${newY}), blocking movement ${direction}`);
          }
        }
      }
    }

    // Keyboard controls
    window.addEventListener('keydown', e => {
      const keyMap = {
        ArrowUp: 'up',
        ArrowDown: 'down',
        ArrowLeft: 'left',
        ArrowRight: 'right'
      };
      
      if (keyMap[e.key]) {
        movePlayer(keyMap[e.key]);
      } else if (e.key === ' ' || e.key === 'Spacebar') {
        // Spacebar for sword swing
        e.preventDefault();
        swingSword();
      }
    });
    
    // Sword swing function
    function swingSword() {
      // Don't do client-side prediction for sword swings - let server handle it
      // This ensures all players see the same sword swing timing
      ws.send(JSON.stringify({ type: "sword_swing" }));
    }

    // Touch controls for mobile D-pad with hold support
    let activeMovement = null;
    let movementInterval = null;
    
    function startMovement(direction) {
      if (activeMovement === direction) return; // Already moving in this direction
      
      // Stop any existing movement
      stopMovement();
      
      activeMovement = direction;
      
      // Move immediately
      movePlayer(direction);
      
      // Set up continuous movement
      movementInterval = setInterval(() => {
        movePlayer(direction);
      }, MOVE_THROTTLE);
    }
    
    function stopMovement() {
      if (movementInterval) {
        clearInterval(movementInterval);
        movementInterval = null;
      }
      activeMovement = null;
    }
    
    document.querySelectorAll('.dpad-button').forEach(button => {
      const direction = button.getAttribute('data-direction');
      
      // Touch events
      button.addEventListener('touchstart', (e) => {
        e.preventDefault();
        startMovement(direction);
      });
      
      button.addEventListener('touchend', (e) => {
        e.preventDefault();
        stopMovement();
      });
      
      button.addEventListener('touchcancel', (e) => {
        e.preventDefault();
        stopMovement();
      });
      
      // Mouse events for testing on desktop
      button.addEventListener('mousedown', (e) => {
        e.preventDefault();
        startMovement(direction);
      });
      
      button.addEventListener('mouseup', (e) => {
        e.preventDefault();
        stopMovement();
      });
      
      button.addEventListener('mouseleave', (e) => {
        e.preventDefault();
        stopMovement();
      });
    });
    
    // Mobile attack button integrated in grid
    document.getElementById('dpad-attack').addEventListener('touchstart', (e) => {
      e.preventDefault();
      swingSword();
    });
    
    document.getElementById('dpad-attack').addEventListener('mousedown', (e) => {
      e.preventDefault();
      swingSword();
    });

    // Draw tiles based on map data
    function drawTiles() {
      // Get tile data directly from map, not from tileData property
      if (!gameState.map || !gameState.map.tileMap || !gameState.map.tileTypes) {
        console.log('No map data available for tile rendering');
        return;
      }
      
      const tileSize = gameState.map.tileSize || 32;
      const tileMap = gameState.map.tileMap;
      const tileTypes = gameState.map.tileTypes;
      
      // Use logical dimensions for viewport calculations
      const viewWidth = canvas.logicalWidth || canvas.width;
      const viewHeight = canvas.logicalHeight || canvas.height;
      
      // Calculate which tiles are visible on screen with some padding to avoid gaps
      const padding = 2; // Extra tiles to render beyond screen edges
      const startTileX = Math.max(0, Math.floor((camera.x - padding * tileSize) / tileSize));
      const endTileX = Math.min(tileMap[0] ? tileMap[0].length - 1 : 0, Math.ceil((camera.x + viewWidth + padding * tileSize) / tileSize));
      const startTileY = Math.max(0, Math.floor((camera.y - padding * tileSize) / tileSize));
      const endTileY = Math.min(tileMap.length - 1, Math.ceil((camera.y + viewHeight + padding * tileSize) / tileSize));
      
      let rocksRendered = 0;
      let grassRendered = 0;
      
      // Draw all visible tiles
      for (let y = startTileY; y <= endTileY; y++) {
        for (let x = startTileX; x <= endTileX; x++) {
          // Ensure we have a valid tile coordinate
          if (y >= 0 && y < tileMap.length && x >= 0 && x < tileMap[y].length) {
            const tileType = tileMap[y][x];
            const tileTypeData = tileTypes[tileType];
            
            if (!tileTypeData) {
              console.log(`Unknown tile type: ${tileType} at (${x}, ${y})`);
              continue;
            }
            
            const drawX = x * tileSize - camera.x;
            const drawY = y * tileSize - camera.y;
            
            // Count tiles for debugging
            if (tileType === 'rocks') rocksRendered++;
            if (tileType === 'grass') grassRendered++;
            
            // Try to draw sprite first
            if (assets.loaded && assets.tiles && assets.tiles[tileType]) {
              ctx.drawImage(assets.tiles[tileType], drawX, drawY, tileSize, tileSize);
            } else {
              // Fallback to color
              const color = tileTypeData.color || '#4a7c59';
              ctx.fillStyle = color;
              ctx.fillRect(drawX, drawY, tileSize, tileSize);
            }
          }
        }
      }
      
      // Debug logging (only log occasionally to avoid spam)
      if (Math.random() < 0.01) {
        console.log(`Rendered ${grassRendered} grass tiles, ${rocksRendered} rock tiles`);
        console.log('Available assets:', Object.keys(assets.tiles || {}));
        console.log('Available tile types:', Object.keys(tileTypes));
      }
    }

    // Draw loop
    function draw() {
      // Use logical dimensions for clearing and background drawing
      const viewWidth = canvas.logicalWidth || canvas.width;
      const viewHeight = canvas.logicalHeight || canvas.height;
      
      ctx.clearRect(0, 0, viewWidth, viewHeight);
      
      // Update camera to follow player
      updateCamera();
      
      // Draw background if available
      if (assets.loaded && assets.backgrounds.grass) {
        const bg = assets.backgrounds.grass;
        
        // Calculate background pattern offset
        const bgOffsetX = -camera.x % bg.width;
        const bgOffsetY = -camera.y % bg.height;
        
        // Only draw background within map boundaries if map data is available
        let drawWidth = viewWidth;
        let drawHeight = viewHeight;
        let drawStartX = bgOffsetX;
        let drawStartY = bgOffsetY;
        
        if (gameState.map && gameState.map.tileMap) {
          // Calculate actual map dimensions from tile grid
          const tileSize = gameState.map.tileSize || 32;
          const mapWidth = gameState.map.tileMap[0] ? gameState.map.tileMap[0].length * tileSize : 0;
          const mapHeight = gameState.map.tileMap.length * tileSize;
          
          // Limit background drawing to within map boundaries
          const mapLeft = -camera.x;
          const mapTop = -camera.y;
          const mapRight = mapWidth - camera.x;
          const mapBottom = mapHeight - camera.y;
          
          // Draw tiled background only within map bounds
          for (let y = Math.max(bgOffsetY, mapTop); y < Math.min(viewHeight, mapBottom); y += bg.height) {
            for (let x = Math.max(bgOffsetX, mapLeft); x < Math.min(viewWidth, mapRight); x += bg.width) {
              // Only draw if within map area
              if (x + bg.width > mapLeft && x < mapRight && y + bg.height > mapTop && y < mapBottom) {
                ctx.drawImage(bg, x, y);
              }
            }
          }
        } else {
          // Fallback: draw tiled background to fill screen when no map data
          for (let y = bgOffsetY; y < viewHeight; y += bg.height) {
            for (let x = bgOffsetX; x < viewWidth; x += bg.width) {
              ctx.drawImage(bg, x, y);
            }
          }
        }
      } else {
        // Fallback solid background if no background image
        // Only draw within map boundaries if available
        if (gameState.map && gameState.map.tileMap) {
          const tileSize = gameState.map.tileSize || 32;
          const mapWidth = gameState.map.tileMap[0] ? gameState.map.tileMap[0].length * tileSize : viewWidth;
          const mapHeight = gameState.map.tileMap.length * tileSize;
          
          // Calculate map area on screen
          const mapLeft = Math.max(0, -camera.x);
          const mapTop = Math.max(0, -camera.y);
          const mapRight = Math.min(viewWidth, mapWidth - camera.x);
          const mapBottom = Math.min(viewHeight, mapHeight - camera.y);
          
          if (mapRight > mapLeft && mapBottom > mapTop) {
            ctx.fillStyle = '#90EE90'; // Light green fallback
            ctx.fillRect(mapLeft, mapTop, mapRight - mapLeft, mapBottom - mapTop);
          }
        } else {
          ctx.fillStyle = '#90EE90'; // Light green fallback
          ctx.fillRect(0, 0, viewWidth, viewHeight);
        }
      }
      
      // Draw tiles if map data is available
      if (gameState.map && gameState.map.tileMap) {
        drawTiles();
        // Draw tile collision outlines after tiles
        drawTileCollisionOutlines();
      }
      
      // Draw players
      for (let id in players) {
        const p = players[id];
        
        // Calculate screen position relative to camera
        const screenX = p.x - camera.x;
        const screenY = p.y - camera.y;
        
        // Only draw if player is visible on screen (with some margin)
        if (screenX > -50 && screenX < viewWidth + 50 && 
            screenY > -50 && screenY < viewHeight + 50) {
          
          // Update swing state based on server data for all players
          if (p.isSwinging) {
            // Only log once when we first detect a swing, not every frame
            if (!p.swingLogged) {
              console.log(`Player ${id} started sword swing, facing: ${p.facing}`);
              p.swingLogged = true;
            }
          } else {
            // Clear the log flag when swing stops
            p.swingLogged = false;
          }
          
          if (assets.loaded) {
            // Initialize animation state if needed
            if (!playerAnimations[id]) {
              playerAnimations[id] = { isMoving: false, lastMoveTime: 0 };
            }
            
            // Check if player should stop moving animation
            const timeSinceMove = Date.now() - playerAnimations[id].lastMoveTime;
            if (timeSinceMove > 500) { // Stop animation 500ms after last move
              playerAnimations[id].isMoving = false;
            }
            
            // Choose sprite based on player type and animation state
            let spriteName;
            if (id === selfId) {
              // Self player sprites - use more stable animation logic
              if (playerAnimations[id].isMoving) {
                spriteName = (Math.floor(animationFrame / 3) % 2 === 0) ? 'player_self1' : 'player_self2';
              } else {
                spriteName = 'player_self1'; // Default to frame 1 when not moving
              }
            } else {
              // Other player sprites
              if (playerAnimations[id].isMoving) {
                spriteName = (Math.floor(animationFrame / 3) % 2 === 0) ? 'player_other1' : 'player_other2';
              } else {
                spriteName = 'player_other1'; // Default to frame 1 when not moving
              }
            }
            
            const sprite = assets.sprites[spriteName];
            if (sprite) {
              // Draw sprite (32x32) centered on player position, adjusted for camera
              ctx.drawImage(sprite, screenX - 16, screenY - 16, 32, 32);
            }
            
            // Draw sword swing effect if player is swinging
            if (p.isSwinging) {
              drawSwordSwing(p, screenX, screenY);
            }
          } else {
            // Fallback to rectangles while assets are loading
            ctx.fillStyle = id === selfId ? 'lime' : 'cyan';
            ctx.fillRect(screenX - 5, screenY - 5, 10, 10);
          }
          
          // Draw player collision outline (10-pixel radius circle)
          drawPlayerCollisionOutline(p.x, p.y, 10);
          
          // Draw player name above the character (adjusted for camera)
          ctx.fillStyle = 'black';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(p.name || 'Player', screenX, screenY - 30);
          
          // Draw player health bar (adjusted for camera)
          if (p.health !== undefined) {
            drawHealthBar(screenX, screenY - 20, p.health, p.maxHealth, 'lime');
          }
        }
      }
      
      // Draw sword swing effect
      function drawSwordSwing(player, screenX = null, screenY = null) {
        // Use provided screen coordinates or calculate from world coordinates
        const drawX = screenX !== null ? screenX : player.x - camera.x;
        const drawY = screenY !== null ? screenY : player.y - camera.y;
        
        // Server-side sword collision parameters (match GameServer.js)
        const swordRange = 20; // SWORD_RANGE from server
        const swordWidth = swordRange / 2; // Arc width (10 pixels each side)
        
        // Get the appropriate sword sprite based on facing direction
        let swordSprite;
        let swordX = drawX;
        let swordY = drawY;
        
        switch(player.facing) {
          case 'up':
            swordSprite = assets.loaded ? assets.sprites.sword_up : null;
            swordX = drawX - 16; // Center horizontally
            swordY = drawY - swordRange - 16; // Position at sword tip (20 pixels up)
            break;
          case 'down':
            swordSprite = assets.loaded ? assets.sprites.sword_down : null;
            swordX = drawX - 16; // Center horizontally
            swordY = drawY + swordRange - 16; // Position at sword tip (20 pixels down)
            break;
          case 'left':
            swordSprite = assets.loaded ? assets.sprites.sword_left : null;
            swordX = drawX - swordRange - 16; // Position at sword tip (20 pixels left)
            swordY = drawY - 16; // Center vertically
            break;
          case 'right':
            swordSprite = assets.loaded ? assets.sprites.sword_right : null;
            swordX = drawX + swordRange - 16; // Position at sword tip (20 pixels right)
            swordY = drawY - 16; // Center vertically
            break;
        }
        
        // Draw the sword sprite if available
        if (swordSprite) {
          ctx.drawImage(swordSprite, swordX, swordY, 32, 32);
        } else {
          // Fallback: Draw sword collision area outline (matching server logic)
          ctx.strokeStyle = '#FFD700'; // Gold color for sword
          ctx.lineWidth = 3;
          ctx.setLineDash([4, 4]); // Dashed line to show it's the collision area
          
          // Calculate sword tip position (matching server logic)
          let swordTipX = drawX;
          let swordTipY = drawY;
          
          switch(player.facing) {
            case 'up': 
              swordTipY -= swordRange;
              // Draw vertical sword collision area
              ctx.strokeRect(drawX - swordWidth, drawY - swordRange, swordWidth * 2, swordRange);
              break;
            case 'down':
              swordTipY += swordRange;
              // Draw vertical sword collision area
              ctx.strokeRect(drawX - swordWidth, drawY, swordWidth * 2, swordRange);
              break;
            case 'left':
              swordTipX -= swordRange;
              // Draw horizontal sword collision area
              ctx.strokeRect(drawX - swordRange, drawY - swordWidth, swordRange, swordWidth * 2);
              break;
            case 'right':
              swordTipX += swordRange;
              // Draw horizontal sword collision area
              ctx.strokeRect(drawX, drawY - swordWidth, swordRange, swordWidth * 2);
              break;
          }
          
          // Draw sword tip circle (where collision is centered)
          ctx.fillStyle = '#FF0000'; // Red tip to show collision center
          ctx.beginPath();
          ctx.arc(swordTipX, swordTipY, 3, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.setLineDash([]); // Reset line dash
        }
        
        // Always draw collision area outline when debug is enabled
        if (showCollisionDebug) {
          ctx.strokeStyle = '#FF8800'; // Orange for sword collision area
          ctx.lineWidth = 2;
          ctx.setLineDash([2, 2]);
          
          // Calculate sword tip position (matching server logic)
          let swordTipX = drawX;
          let swordTipY = drawY;
          
          switch(player.facing) {
            case 'up': 
              swordTipY -= swordRange;
              // Draw the actual collision rectangle
              ctx.strokeRect(drawX - swordWidth, drawY - swordRange, swordWidth * 2, swordRange);
              break;
            case 'down':
              swordTipY += swordRange;
              ctx.strokeRect(drawX - swordWidth, drawY, swordWidth * 2, swordRange);
              break;
            case 'left':
              swordTipX -= swordRange;
              ctx.strokeRect(drawX - swordRange, drawY - swordWidth, swordRange, swordWidth * 2);
              break;
            case 'right':
              swordTipX += swordRange;
              ctx.strokeRect(drawX, drawY - swordWidth, swordRange, swordWidth * 2);
              break;
          }
          
          // Draw sword tip collision circle
          ctx.strokeStyle = '#FF0000';
          ctx.beginPath();
          ctx.arc(swordTipX, swordTipY, swordRange, 0, Math.PI * 2);
          ctx.stroke();
          
          ctx.setLineDash([]);
        }
      }
      
      // Draw enemies
      for (let id in enemies) {
        const enemy = enemies[id];
        
        // Calculate screen position relative to camera
        const screenX = enemy.x - camera.x;
        const screenY = enemy.y - camera.y;
        
        // Only draw if enemy is visible on screen (with some margin)
        if (screenX > -50 && screenX < canvas.width + 50 && 
            screenY > -50 && screenY < canvas.height + 50) {
          
          if (assets.loaded && assets.sprites.enemy) {
            // Draw enemy sprite (adjusted for camera)
            ctx.drawImage(assets.sprites.enemy, screenX - 16, screenY - 16, 32, 32);
          } else {
            // Fallback to red rectangle while assets are loading
            ctx.fillStyle = 'red';
            ctx.fillRect(screenX - 5, screenY - 5, 10, 10);
          }
          
          // Draw enemy collision outline (10-pixel radius circle)
          drawPlayerCollisionOutline(enemy.x, enemy.y, 10);
          
          // Draw enemy name above the character (adjusted for camera)
          ctx.fillStyle = 'red';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(enemy.name || 'Enemy', screenX, screenY - 30);
          
          // Draw enemy health bar (adjusted for camera)
          if (enemy.health !== undefined) {
            drawHealthBar(screenX, screenY - 20, enemy.health, enemy.maxHealth, 'red');
          }
        }
      }
      
      // Health bar drawing function
      function drawHealthBar(centerX, y, currentHealth, maxHealth, color) {
        const barWidth = 30;
        const barHeight = 4;
        const x = centerX - barWidth / 2;
        
        // Background (black border)
        ctx.fillStyle = 'black';
        ctx.fillRect(x - 1, y - 1, barWidth + 2, barHeight + 2);
        
        // Background (dark gray)
        ctx.fillStyle = '#333';
        ctx.fillRect(x, y, barWidth, barHeight);
        
        // Health bar (colored)
        const healthPercentage = Math.max(0, currentHealth / maxHealth);
        const healthWidth = barWidth * healthPercentage;
        ctx.fillStyle = color;
        ctx.fillRect(x, y, healthWidth, barHeight);
      }
      
      // Collision debug drawing
      if (showCollisionDebug && gameState.map && gameState.map.tileMap) {
        ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)'; // Red color for collision outlines
        ctx.lineWidth = 2;
        
        // Draw collision outlines for all tiles
        for (let y = 0; y < gameState.map.tileMap.length; y++) {
          for (let x = 0; x < gameState.map.tileMap[y].length; x++) {
            const tileType = gameState.map.tileMap[y][x];
            const tileData = gameState.map.tileTypes[tileType];
            
            if (tileData && (!tileData.walkable || tileData.collision)) {
              // Tile is not walkable or has collision, draw outline
              const drawX = x * gameState.map.tileSize - camera.x;
              const drawY = y * gameState.map.tileSize - camera.y;
              ctx.strokeRect(drawX, drawY, gameState.map.tileSize, gameState.map.tileSize);
            }
          }
        }
      }
      
      // Display collision debug info
      if (showCollisionDebug) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(10, 10, 240, 80);
        ctx.fillStyle = '#FFFFFF';
        ctx.font = '12px Arial';
        ctx.fillText('Collision Debug (Press C to toggle)', 15, 25);
        ctx.fillStyle = '#00FF00';
        ctx.fillText('Green circles: Player/Enemy hitbox (R:10)', 15, 40);
        ctx.fillStyle = '#FF0000';
        ctx.fillText('Red squares: Rock collision tiles', 15, 55);
        ctx.fillStyle = '#FF8800';
        ctx.fillText('Orange rectangles: Sword collision area (20x10)', 15, 70);
        ctx.fillStyle = '#FFD700';
        ctx.fillText('Red circles: Sword tip range (R:20)', 15, 85);
      }
      
      requestAnimationFrame(draw);
    }

    draw();
  </script>
</body>
</html>
